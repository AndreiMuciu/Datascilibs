repo_full_name,issue_id,comment_id,user_login,user_id,created_at,updated_at,body,reactions_total,reactions_plus1,reactions_minus1,reactions_laugh,reactions_hooray,reactions_confused,reactions_heart
eriklindernoren/ML-From-Scratch,2674954403,2691170380,levietnguyen,59528467,2025-02-28T17:18:59+00:00,2025-02-28T17:18:59+00:00,"## Simply Change `return np.array(sets)` in `data_manipulation.py` to `return sets`

### **Explanation:**
### **Why Returning `sets` Works Instead of `np.array(sets)`**
The fix works because of how NumPy handles arrays with complex nested structures. Here's why:

### **The Original Problem**
When the code attempted to return `np.array(sets)`, it was trying to convert a list of lists (where each inner list contains arrays of potentially different shapes) into a **homogeneous NumPy array**.

### **Why This Fails**
NumPy arrays are designed to hold elements of the same type and, more importantly, elements that can be arranged in a **regular grid**. When you have a list like `sets` where each element contains:

- `X_train`: A **2D array** with shape **(varying_size, n_features)**
- `X_test`: A **2D array** with shape **(smaller_size, n_features)**
- `y_train`: A **1D array** with shape **(varying_size,)**
- `y_test`: A **1D array** with shape **(smaller_size,)**

NumPy **can't create a regular grid structure** to hold these heterogeneous shapes.

### **What Happens When `np.array(sets)` is Used**
When NumPy tries to convert this irregular structure to an array, it attempts to create what's called a **""ragged array""**—an array where the **size of dimensions can vary**. 

- NumPy **does not directly support ragged arrays**, so it tries to use an **object array** (i.e., an array of Python objects).
- This approach **fails** when the objects themselves have complex, nested structures with **inconsistent dimensions**.

### **Why Returning `sets` Works**
By returning `sets` as a **plain Python list** instead of converting it to a NumPy array:

✅ You **preserve the original structure** without forcing it into a rigid NumPy array format.  
✅ The **consumer code** can iterate through the list and access each fold's data directly.  
✅ Each element **retains its original NumPy array properties** for `X_train`, `X_test`, `y_train`, and `y_test`.  

### **Final Fix:**
Replace:
```python
return np.array(sets)
```
With:
```python
return sets
```
This ensures that the k-fold cross-validation sets remain correctly formatted and usable.",0,0,0,0,0,0,0
eriklindernoren/ML-From-Scratch,2204285450,2106269395,MohdRasmil7,95293649,2024-05-12T14:41:59+00:00,2024-05-12T14:41:59+00:00,"The coefficient in the normal equation for the Gaussian distribution (also known as the probability density function) should indeed be:

[ \text{coeff} = \frac{1}{\sqrt{2\pi}} + \epsilon ]

where:

(\pi) represents the mathematical constant pi (approximately 3.14159).
(\epsilon) is a small value (usually added for numerical stability).
The square root of (2\pi) should be inside the square root, not outside. Here’s the corrected expression:

[ \text{coeff} = \frac{1}{\sqrt{2\pi}} + \epsilon ]",0,0,0,0,0,0,0
